# Data_Structure
자료구조
>- <a href="#array">배열</a> 
>- <a href="#list">리스트</a> 
>- <a href="#stack">스택</a>


<br>
<br>

# <div id="array">배열(Array)</div>
## 정의
 Array(배열) : 한 종류의 데이터 타입을 연속적으로 메모리에 저장한 집합이다.
```
int array[10] = {0,1,2,3,4,5,6,7,8,9};
```

예를 들어 int 타입 데이터 10개를 연속적인 메모리에 저장하게 해주는 것이 배열이다.
<br>  
<br>


## 특징  

### 인덱스[index]
배열은 `인덱스[index]`를 통해 배열의 요소{0,1,2...}에 접근할 수 있다.  
이는 물리적으로 순서가 연결되어 있기 때문이다.  

```
printf("%d",array[0]); // 0을 출력한다.
printf("%d",array[1]); // 1을 출력한다.
printf("%d",array[2]); // 2를 출력한다.
```

배열의 인덱스는 항상 0부터 시작 한다.  
따라서 array 변수의 경우, 10개의 int 타입 데이터를 가지고 있기 때문에 인덱스는 0부터 9까지이다.  
배열은 물리적으로 순서가 연결되어 있기 때문에, 인덱스를 통해 O(1)의 시간복잡도로 해당 요소에 접근이 가능하다.  
<br>
일반 변수와 달리 배열 변수 안에는 배열이 시작하는 지점의 메모리 주소를 가진다.
```
printf("%p", array); // 00B8FA70 메모리 위치 출력(16진수)
printf("%d", sizeof(int)); // int는 4 byte
```

따라서  
0의 메모리 위치는 00B8FA70  
1의 메모리 위치는 00B8FA74  
2의 메모리 위치는 00B8FA78  
...  

<br>  
<br>

## 생각
>다른 자료 구조들에 비해 배열의 유일한(?) 특징은 [연속적인 메모리 위치]라고 생각한다. 다른 자료 구조들의 경우 데이터가 나란히 이어져 있는 경우는 있지만, 물리적으로 메모리가 이어져 있는 경우는 (내가 알기론) 없기 때문이다.
___
<br>
<br>
<br>
<br>

# <div id="list">리스트(List)</div>
## 정의
List(리스트) : n개의 데이터 타입이 서로 연결되어 순서가 있다.  
리스트의 각각의 요소들이 서로 연결되어져 있다.  

<br>

## 특징
리스트는 아래와 같이 2가지로 구현할 수 있다.
1. 배열  
2. 연결 리스트

<br>
<br>

 ## 1. 배열(Array)
배열의 경우 구현이 간단하지만  
삽입,삭제시 때에 따라 리스트의 순서를 유지하기 위해 배열의 많은 요소들을 하나씩 옮겨야 하기 때문에 비효율적이다.  
또한 배열을 선언한 이후에, 크기를 늘리거나 줄일 수 없는 정적인(static) 형태를 가지고 있다.  

C언어의 경우 일반적인 지역변수나 배열은 Stack이라는 메모리에 저장이 된다.  
이 Stack에 저장된 변수는 프로그램이 종료되면 자동적으로 메모리가 해제된다. 

> ### 삽입
> <img height=200 src="ListArray/List_array_insert.gif">   
B와 D 사이에 C를 삽입하기 위해 D름 포함하여 뒤에 있는 모든 데이터를 옮겨야 한다.    
  
  <br>
  <br>

> ### 삭제  
> <img height=200 src="ListArray/List_array_remove.gif"> 
C를 삭제했다면, 서로 연결되어 지기 위해 , D를 포함한 뒤에 있는 모든 데이터를 옮겨야 한다.  

<br>
<br>

## 2. 연결 리스트(LinkedList)
연결 리스트의 경우 구현이 복잡하지만 삽입,삭제가 효율적이고  
프로그램 사용 도중 유동적으로 리스트의 크기를 줄이고 늘릴 수 있는 동적인(dynamic) 형태를 가진다.  
C언어의 경우 Heap 영역에 메모리를 할당하여 사용한다.  

연결 리스트의 경우 __노드(Node)__ 를 하나 생성하여 노드간에 서로 연결지어 준다.  
노드는 1. 데이터 필드 2. 링크 필드로 구성되어 진다.
1. 데이터 필드(Data Field) : 데이터를 저장하는 공간  
2. 링크 필드 (Link Field) : 다른 노드의 주소 값을 저장하는 장소
   
아래는 C 언어에서의 노드를 구성하는 구조체 이다.  
```
typedef struct _Node{
    int data; // 데이터 필드
    struct _Node* next; // 링크 필드
}Node;
```
>노드 간 연결    
<img width=500 src="LinkedList/Singly_Linked_List.png">  

이와 같이 노드에 데이터가 저장되며, 자기 자신에 대한 포인터를 사용하여 노드간에 서로 연결 시킨다.  
연결 리스트는 이 구조체에 Heap 메모리를 할당하여 랜덤한 위치의 메모리를 사용한다. 때문에 노드간에 물리적으로 연결되어 있지는 않다.  
하지만 다음 노드에 대한 주소를 가지고 있으므로 __논리적으로 순서가 연결__ 되어 있다.  
때문에 원하는 데이터를 탐색(Search)하기 위하여 모든 노드의 갯수(n)만큼 탐색하기 때문에 O(n)의 시간복잡도를 가진다. 
<br>
<br>
Heap에 메모리를 할당하였다면, **프로그램이 종료되기 전에 반드시 적절한 메모리 해제 명령어를 작성해야 한다.**  
그렇지 않으면, 사용중인 메모리는 프로그램이 종료 되어도 사라지지 않는다. 따라서 메모리를 해제해 주지 않는다면  
우리는 다음번에 해당 위치의 메모리를 사용할 수 없다. 이러한 현상을 <span style="color:powderblue">**메모리 누수 현상**</span>이라고 부른다.  

이 메모리 누수 현상이 쌓이다 보면, 더 이상 메모리를 사용할 수 없게되어 프로그램이 다운되고 만다. 그러니
각별히 신경써야 한다.   
때문에 Java 같은 언어에서는 Garbage Collect라는 메모리 관리 시스템을 가지고 있어, 사람이 신경쓰지 않아도 자동적으로  
메모리를 해제하여 메모리 누수 현상을 막아준다.  

연결 리스트의 종류는 크게 3가지가 있다.
>1. 단순 연결 리스트(Singly Linked List)  
<img width=500 src="LinkedList/Singly_Linked_List.png">

>2. 원형 연결 리스트(Circular Linked List)  
<img width=400 src="LinkedList/Circular_Linked_List.png">

>3. 아중 연결 리스트(Doubly Linked List)  
<img width=500 src="LinkedList/Doubly_Linked_List.png">
___
<br>
<br>
<br>
<br>

# <div id="stack">스택(Stack)</div>
## 정의
>Stack(스택) : 탑(top)에 의해 삽입과 삭제가 이루어지는 정렬된 리스트  

<br>
<br>

## 특징
>스택은 쉽게 말해 상자 쌓기와 비슷하다.  
 
 창고에서 상자를 정리하기 위해서는 맨 처음에 상자를 바닥에 두고, 그 다음 상자를 위에 올린다.  

이와같이 데이터가 아래부터 위로 쌓아 올라가는 듯한 형태의 자료구조가 스택이다. 이 때 가장 최근에 삽입된 데이터를 탑(Top)이라고 부르며 데이터가 삽입(push) 및 삭제(pop)될 때 항상 탑을 기준으로 작동한다.  
 
비어있는 스택에 데이터 A0가 삽입되면 A0가 탑이 된다.  
이후에 데이터 A1이 삽입되면 탑(A0) 위에 A1이 쌓이면서 A1이 탑이된다.  
<img width = 150 src="Stack/Stack_push.gif">  
<br>
반대로 스택에 쌓인 데이터를 삭제한다면 맨 위에 쌓여있는 데이터 부터 즉, 가장 최근에 삽입된 데이터(A4) 먼저 삭제된다.   
<img width = 150 src="Stack/Stack_pop.gif">  

이러한 특징을 **LIFO(Last In First Out)** 라고 부른다.   
**가장 최근에 들어온 데이터가 먼저 나가는 특징을 가지고 있다.**  

<br>
<br>

## 생각
>스택은 대표적으로 미로찾기 알고리즘,후위식 및 전위식 계산에 쓰이는 자료구조 이다.